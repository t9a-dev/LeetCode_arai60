// Step1
// 目的: 方法を思いつく

// 方法
// 5分考えてわからなかったら答えをみる
// 答えを見て理解したと思ったら全部消して答えを隠して書く
// 5分筆が止まったらもう一回みて全部消す
// 正解したら終わり

/*
  問題の理解
  - 浮動小数点xと整数nが与えられるのでx ^ nを計算して返す。

  何を考えて解いていたか
  - 素直にループで書く方向で考える。
  - pow *= xをn回行う。
    - nが0未満のときは最後に除算する。(1/pow)

  何がわからなかったか
  - n==0のとき(xの0乗)をが1になることを忘れていた。
  - x=0.00001 n=2147483647 のときにTime Limit Exceededになった。
  - テストコードでassert_eq!による比較をすると浮動小数点の桁数全てで完全一致を要求するので、桁数を丸めて比較すべきだった。
  数学のテクニック的な感じでナイーブな実装を行うのではなく効率的な計算方法がある気がするがわからないので解答を見る。

  解法の理解
  LeetCodeの解答例を見てもなぜそうしているのかがよく分からないのでGPT-5.2に聞いた。
  TLE: Time Limit Exceeded
  - ナイーブな実装だとn回計算を行うことになり時間計算量O(n)となる。入力の制約からnはi32::MIN ~ i32::MAXまで取り得るので最悪21億回のループになりTLEとなる。
  - 数学的な性質で指数を半分にして計算できるので時間計算量O(log n)になる。
    - 偶数
      x ^ 10 = (x^5)^2
    - 奇数
      x ^ 11 = x * (x^5)^2

  正解してから気づいたこと
  - TLEすることを予想したうえでナイーブな実装をしたかった。TLEすること自体は理解できるので、余裕を持って周りを見渡しながら実装に取り組めるかという慣れの問題だと思った。
  - i32::MIN ~ i32::MAXは (2 ^ -31) ~ (2 ^ 31) - 1 になるので、i32::MINを符号を反転させるとi32::MAXに収まりきらずオーバーフローすることに気づかなかった。
    - 32bitのうち符号を表すために1ビット使うので-1しているということは知識としてはあったが扱う機会がないので気づかなかった。
  - 指数の数学的な性質を知っているか、知っている場合コーディングで表現できるかという問題だと思った。あまり深堀りすることはなさそうだと思った。
  ループでの解法も練習しておく。step1a.rs
*/

pub struct Solution {}
impl Solution {
    pub fn my_pow(x: f64, n: i32) -> f64 {
        if n == 0 {
            return 1.0;
        }

        // x,nは参照ではないのでmutableにしても呼び出し元に影響を与えない。
        let (mut x, mut n) = (x, n as i64);
        if n < 0 {
            x = 1.0 / x;
            n = n.abs();
        }

        let half = Self::my_pow(x, (n / 2) as i32);
        if n % 2 == 0 {
            return half * half;
        }

        return x * half * half;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_5(v: f64) -> f64 {
        (v * 1e5).round() / 1e5
    }

    #[test]
    fn step1_test() {
        assert_eq!(round_5(Solution::my_pow(2.00000, 10)), 1024.00000);
        assert_eq!(round_5(Solution::my_pow(2.10000, 3)), 9.26100);
        assert_eq!(round_5(Solution::my_pow(2.00000, -2)), 0.25000);
    }

    #[test]
    fn step1_not_overflow_test() {
        assert!(Solution::my_pow(1.00000, i32::MAX).is_sign_positive());
        assert!(Solution::my_pow(1.00000, i32::MIN).is_sign_positive());
    }
}
