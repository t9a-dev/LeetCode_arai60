// Step1
// 目的: 方法を思いつく

// 方法
// 5分考えてわからなかったら答えをみる
// 答えを見て理解したと思ったら全部消して答えを隠して書く
// 5分筆が止まったらもう一回みて全部消す
// 正解したら終わり

/*
  問題の理解
  - 整数nとkが与えられる。n,kは1から始まる。
  n行の表を考えるとき、1行目,1番目の数字を0でスタートする。2行目から直前の行の数字を0->01,1->10に変更した数字を書き込む。
  n=4,k=2のときoutput=1となる。
  1行目: 0
  2行目: 01
  3行目: 0110
  4行目: 01101001
  となる。

  入力の制約:
  1 <= n <= 30
  1 <= k <= 2 ^ (n - 1)

  何を考えて解いていたか
  - n行目だけわかればよいので表全体をメモリに保持しておく必要は無さそう。
  - 入力の制約からkはi32の上限ギリギリの値を取り得るので、計算量に注意が必要そう。
  - 1行増えるたびに行が持つ数値の数が倍になっていくので、k番目の数字を定数時間O(1)で取得するために配列で管理すると空間計算量が爆発しそう。
  bit列で計算しても 2 ^ (29) で計算すると約536MBになるので、ナイーブな実装ではだめそう。
  ただし、n行目の結果をn-1行目の結果から計算できれば 2 ^ (log n) となり空間計算量は問題ないと考えられる。
  n行目のk番目の数字は、n-1行目の(k%2 == 1 then k - (k/2) else k/2 )番目の数字から求められる。
  n行目k番目の数字はn-1行目の(k%2 == 1 then k - (k/2) else k/2 )番目の数字に対応している。
  3,4 = 2
  5,6 = 3
  7,8 = 4
  - n行目の値は、n-1行目のbit列にn-1行目の反転bitをくっつけている
  - bitを渡すと、渡したbitを反転したbitをくっつけた全体のビット列を返す処理が必要。

  ここまで考えてbit操作がよく分からず実装の手がとまったので解答を見る。

  何がわからなかったか
  - bit列の操作
    - bit列を反転したbit列を反転前のbit列と結合する処理
    - k番目のbit列を求める処理

  解答の理解
  https://leetcode.com/problems/k-th-symbol-in-grammar/solutions/4205266/100-recursive-bit-count-by-vanamsen-ctv2/
  - 注目している点
    - n行目のbit列の長さはn-1行目のbit列の長さの2倍になる。
    - kがn行目の前半部分である場合、n-1行目のk番目とそのまま対応する。
      - kがn行目の後半部分である場合、n-1行目のbit列を反転した値のk番目に対応する。
  - 1 << (n - 2) が何をしているのか見てすぐに分からない。
    - 1 << (n - 2) で　2 ^ (n - 2)と等価になる。
      - 0001を左に(n-2)bitシフトしている。
    - n=4のときbit列の長さは8になる。 1 << (n - 2) = 4となり、前後半の境界を求められる。
  - 1 << (n - 2)によって求めたbit列の前後半で条件分岐している。
    - k <= length: kが前半部分のとき、そのままn-1行目k番目の値を返している。
      else: kが後半部分の時、k - lengthにより後半部分のk番目の値を1 - x により反転して返している。

  正解してから気づいたこと
  - bit演算に慣れていないせいか難しく感じる。k番目のbitを返しているという内容を実装から読み取るのが難しいという感覚。
  - 問題の制約的にはあり得ないが、n,kが1以上であることを検証した方が良いと思った。

  所感
  - 他の人のコードを読んで写経するのが良さそう。
*/

pub struct Solution {}
impl Solution {
    pub fn kth_grammar(n: i32, k: i32) -> i32 {
        if n == 1 {
            return 0;
        }

        let length = 1 << (n - 2);
        if k <= length {
            return Self::kth_grammar(n - 1, k);
        }
        1 - Self::kth_grammar(n - 1, k - length)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn step1_test() {
        assert_eq!(Solution::kth_grammar(1, 1), 0);
        assert_eq!(Solution::kth_grammar(2, 1), 0);
        assert_eq!(Solution::kth_grammar(2, 2), 1);
    }
}
