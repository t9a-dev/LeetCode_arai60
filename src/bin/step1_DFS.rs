// Step1
// 目的: 方法を思いつく

// 方法
// 5分考えてわからなかったら答えをみる
// 答えを見て理解したと思ったら全部消して答えを隠して書く
// 5分筆が止まったらもう一回みて全部消す
// 正解したら終わり

/*
  問題の理解
  - 二次元配列gridが与えられる。gridに含まれる配列中の値は"1"(陸地)、"0"(水域)で構成される。gridに含まれる島の数を返す。
  島の定義
  - 隣接する上下左右が水域であること。
  - 隣接する上下左右に陸地がある場合は島の一部として判定する。（陸地が連続しているので島の一部になる。）

  何がわからなかったか
  - 連続する陸地を見つけたときに、一つの島としてカウントする必要があるので、どこまで陸地が続いているのか探索？する必要があるが、具体的な実装手法わからなかった。
  - Arai60のカテゴリではGraph,BFS,DFSとなっている。BFS,DFSは知らない単語だった。

  何を考えて解いていたか
  - 値が数字文字として渡ってきて取り回しが悪いので最初に0,1の数値に変換して使う。
  - 陸地と水域のenumを作って、判定などで利用したい。
  - ある座標を与えると、陸地か水域かを返すメソッドを作りたい。
  - ある座標を与えると、その座標の上下左右を算出して陸地か水域かを判定するメソッドを作りたい。
    - アクセスできない範囲の配列は水域として判定する必要がある。
  - 島と判定された座標を管理するHashSetが必要だと思った。
  - ここまで考えて手を動かし始めたが、実装できる見通しが立たず時間を使っていたので答えを見ることにした。
  - Graph,BFS,DFSというカテゴリらしいが、このBFS,DFSという単語自体を知らないので調べる必要がある。

  データ構造とアルゴリズムの文脈におけるGraph,BFS,DFSについて
  https://qiita.com/drken/items/4a7869c5e304883f539b

  - 深さ優先探索(Depth-First Search,DFS)、幅優先探索(Breadth-First Search,BFS)
  https://qiita.com/drken/items/4a7869c5e304883f539b#3-%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2-dfs-%E3%81%A8%E5%B9%85%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2-bfs
    - DFS
    次に辿れる経路を見つけ次第どんどん辿っていき最下位層まで行くイメージ。
    - BFS
    次に辿れる経路が同じ階層に複数ある場合、それらをリストアップしておいて、リストアップしておいた経路を全て辿るまで次の階層に行かないイメージ
    階層毎に全て辿っている。
  今回の問題では陸地がどこまで続くか見るので深さ優先探索が自然に考えられると思った。
  概要は分かったので実装例を見て実際に何をしているのかの理解を優先する。

  実装例の理解
  https://leetcode.com/problems/number-of-islands/solutions/1081273/rust-dfs-solution/
  ナイーブな実装に見えるので何をしているのか理解しやすそうだと判断。
  - x,yがともに0（左上）の座標が1(陸)のときに一つの島としてカウントしているのは、左と上が水域であることが確定しているので、右と下が陸、水域どちらであっても島であることが確定するため。
  - 1（陸）を見つけるたびに深さ優先探索をして水域を見つけるまで陸を探索し続けている。一度探索したら0（水域）にすることでチェック済としている。
    - 何をしているのかは分かったが、問題をみてこの解法を思いつくまでにはかなり距離があるように感じる。
      - 位置0,0が1であれば島としてカウントできることに気づけなさそう。

  正解してから気づいたこと
  - DFS,BFSは知らない単語だったので面食らったが、全走査するときに優先的にどの順番で見に行くのかという違いであると理解した。
    - 一番深いところまで潜るのか、移動する距離を一定区間ずつ増やしながら探索開始地点から近いところを見ていくのか。

  所感
  - 一度理解したと思ってから実装したときに上、左、上方向の移動をしない実装をしてしまった。
  水域で断絶されるものの別の経路からはたどり着くようなパターンに対応するために上下左右全ての移動が必要だと理解できた。
  - ChatGPTに聞いたところBFSでも解けるそうなので理解を深めるために実装してみる。
*/

pub struct Solution {}
impl Solution {
    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {
        let mut islands_count = 0;
        let mut grid = grid;

        for y in 0..grid.len() {
            for x in 0..grid[y].len() {
                if grid[y][x] == '1' {
                    Self::islands_exploer(&mut grid, x, y);
                    islands_count += 1;
                }
            }
        }

        islands_count
    }

    fn islands_exploer(grid: &mut Vec<Vec<char>>, x: usize, y: usize) {
        if let Some(rows) = grid.get_mut(y) {
            if let Some(v) = rows.get_mut(x) {
                if *v == '0' {
                    return;
                }

                *v = '0';
                // 右へ
                if rows.get(x + 1).is_some() {
                    Self::islands_exploer(grid, x + 1, y);
                }
                // 下へ
                if grid.get(y + 1).is_some() {
                    Self::islands_exploer(grid, x, y + 1);
                }
                // 左へ
                if x > 0 {
                    Self::islands_exploer(grid, x - 1, y);
                }
                // 上へ
                if y > 0 {
                    Self::islands_exploer(grid, x, y - 1);
                }
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn step1_dfs_test() {
        let grid = vec![
            vec!['1', '1', '1', '1', '0'],
            vec!['1', '1', '0', '1', '0'],
            vec!['1', '1', '0', '0', '0'],
            vec!['0', '0', '0', '0', '0'],
        ];
        assert_eq!(Solution::num_islands(grid), 1);

        let grid = vec![
            vec!['1', '1', '0', '0', '0'],
            vec!['1', '1', '0', '0', '0'],
            vec!['0', '0', '1', '0', '0'],
            vec!['0', '0', '0', '1', '1'],
        ];
        assert_eq!(Solution::num_islands(grid), 3);

        let grid = vec![
            vec!['1', '1', '1'],
            vec!['0', '1', '0'],
            vec!['1', '1', '1'],
        ];
        assert_eq!(Solution::num_islands(grid), 1);

        let grid = vec![
            vec!['0', '0', '1', '1', '1'],
            vec!['0', '0', '1', '1', '1'],
            vec!['0', '0', '1', '0', '1'],
            vec!['1', '1', '1', '1', '1'],
            vec!['1', '1', '1', '0', '0'],
            vec!['1', '1', '1', '0', '0'],
            vec!['1', '0', '1', '0', '0'],
            vec!['1', '1', '1', '0', '0'],
        ];
        assert_eq!(Solution::num_islands(grid), 1);
    }
}
